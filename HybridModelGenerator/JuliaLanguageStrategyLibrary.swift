//
//  JuliaLanguageStrategyLibrary.swift
//  HybridModelGenerator
//
//  Created by Jeffrey Varner on 6/5/15.
//  Copyright (c) 2015 Pooksoft. All rights reserved.
//

import Cocoa

protocol CodeGenerationStrategy {
    
    func execute(node:SyntaxTreeComponent) -> String
}


class JuliaLanguageStrategyLibrary: NSObject {

    // vars -
    static var my_input_url:NSURL?
    
    // make a bunch of static methods that return stuff -
    static func appendNewLineToBuffer(inout buffer:String) -> Void {
        buffer+="\n"
    }
    
    // build function header information -
    static func buildCopyrightHeader(functionName:String, functionDescription:String) -> String {
        
        // declarations -
        var buffer = ""
        
        // Get the date -
        let flags: NSCalendarUnit = NSCalendarUnit.CalendarUnitDay | NSCalendarUnit.CalendarUnitMonth | NSCalendarUnit.CalendarUnitYear
        let date = NSDate()
        let components = NSCalendar.currentCalendar().components(flags, fromDate: date)
        let year_string = components.year
        let day_string = components.day
        let month_string = components.month
        let user_name = NSUserName()
        
        buffer+="# ------------------------------------------------------------------------------------- #\n"
        buffer+="# Copyright (c) \(year_string) Varnerlab,\n"
        buffer+="# School of Chemical and Biomolecular Engineering,\n"
        buffer+="# Cornell University, Ithaca NY 14853 USA.\n"
        buffer+="#\n"
        buffer+="# Permission is hereby granted, free of charge, to any person obtaining a copy\n"
        buffer+="# of this software and associated documentation files (the \"Software\"), to deal\n"
        buffer+="# in the Software without restriction, including without limitation the rights\n"
        buffer+="# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n"
        buffer+="# copies of the Software, and to permit persons to whom the Software is\n"
        buffer+="# furnished to do so, subject to the following conditions:\n"
        buffer+="# The above copyright notice and this permission notice shall be included in\n"
        buffer+="# all copies or substantial portions of the Software.\n"
        buffer+="#\n"
        buffer+="# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n"
        buffer+="# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n"
        buffer+="# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n"
        buffer+="# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n"
        buffer+="# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n"
        buffer+="# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n"
        buffer+="# THE SOFTWARE.\n"
        buffer+="#\n"
        buffer+="# \(functionName)\n"
        buffer+="# \(functionDescription)\n"
        buffer+="#\n"
        buffer+="# Generated on: \(month_string)/\(day_string)/\(year_string)\n"
        buffer+="# Generated by: \(user_name)\n"
        
        // if we have a input URL, then write down the file name -
        if let local_input_file_url = JuliaLanguageStrategyLibrary.my_input_url {
            
            // get the file name -
            if let local_file_name = local_input_file_url.lastPathComponent {
                
                buffer+="# Source file: \(local_file_name)\n"
            }
        }
        
        buffer+="# ------------------------------------------------------------------------------------- #\n"
        
        // return the buffer back to caller -
        return buffer
    }
    
}

class JuliaProjectIncludeFileStrategy:CodeGenerationStrategy {
    
    func execute(node:SyntaxTreeComponent) -> String {
        
        // declarations -
        var buffer:String = ""
        
        // get the copyright header information -
        var header_information = JuliaLanguageStrategyLibrary.buildCopyrightHeader("Project.jl",
            functionDescription: "Include statements for all model files.")
        
        buffer+="\(header_information)"
        buffer+="include(\"DataFile.jl\")\n"
        buffer+="include(\"Balances.jl\")\n"
        buffer+="include(\"Control.jl\")\n"
        buffer+="include(\"Kinetics.jl\")\n"
        buffer+="include(\"SolveBalanceEquations.jl\")\n"
        
        // return -
        return buffer
    }
}

class JuliaSolveBalanceEquationsFileStrategy:CodeGenerationStrategy {
    
    func execute(root:SyntaxTreeComponent) -> String {
        
        // declarations -
        var buffer:String = ""
        
        buffer+="# Include statements - \n"
        buffer+="include(\"DataFile.jl\")\n"
        buffer+="include(\"Balances.jl\")\n"
        buffer+="using Sundials\n"
        buffer+="\n"
        
        // get the copyright header information -
        var header_information = JuliaLanguageStrategyLibrary.buildCopyrightHeader("SolveBalanceEquations.jl",
            functionDescription: "Solve the balance equations using CVODE from the SUNDIALS package.")
        
        buffer+="\(header_information)"
        buffer+="function SolveBalanceEquations(TSTART,TSTOP,Ts,DF)\n"
        buffer+="\n"
        
        buffer+="\t# Do we have a modified data dictionary? - \n"
        buffer+="\tif (length(DF) == 0)\n"
        buffer+="\t\tDFIN = DataFile(TSTART,TSTOP,Ts,-1);\n"
        buffer+="\telse\n"
        buffer+="\t\tDFIN = DF;\n"
        buffer+="\tend\n"
        buffer+="\n"
        buffer+="\t# Setup the simulation time scale - \n"
        buffer+="\tTSIM = [TSTART:Ts:TSTOP];\n"
        buffer+="\n"
        buffer+="\t# Grab the initial conditions from the data dictionary -\n"
        buffer+="\tinitial_condition_vector = DFIN[\"INITIAL_CONDITION_VECTOR\"];\n"
        buffer+="\n"
        buffer+="\t# Setup and call the ODE solver - \n"
        buffer+="\tfbalances(t,y,ydot) = Balances(t,y,ydot,DFIN);\n"
        buffer+="\tX = Sundials.cvode(fbalances,initial_condition_vector,TSIM);\n"
        buffer+="\n"
        buffer+="\treturn (TSIM,X);\n"
        buffer+="end"
        
        // return -
        return buffer
    }
}

class JuliaDataFileFileStrategy:CodeGenerationStrategy {
    
    func execute(root:SyntaxTreeComponent) -> String {
        
        // declarations -
        var buffer:String = ""
        
        // get the copyright header information -
        var header_information = JuliaLanguageStrategyLibrary.buildCopyrightHeader("DataFile.jl",
            functionDescription: "Creates a data dictionary holding initial conditions, and the kinetic/control\n# parameters for the model. Called by SolveBalanceEquations.jl")
        
        buffer+="\(header_information)"
        buffer+="function DataFile(TSTART,TSTOP,Ts,INDEX)\n"
        buffer+="\n"
        
        // Initialize -
        buffer+="\t# Set the initial condition - \n"
        buffer+="\tIC_ARRAY = Float64[]\n"
        
        // Build IC list -
        var model_root = root as! SyntaxTreeComposite
        if var species_list = extractSpeciesList(model_root) {
            
            var counter = 1
            for proxy_object in species_list {
                
                // Get the default value -
                let default_value = proxy_object.default_value
                let state_symbol = proxy_object.state_symbol_string
                
                // write the record -
                buffer+="\tpush!(IC_ARRAY,\(default_value!))\t"
                buffer+="#\t\(counter)\t\(state_symbol!)\n"
                
                // update the counter -
                counter++
            }
        }
        
        // Build the list of gene expression kinetic parameters -
        buffer+="\t# Setup the gene expression kinetic parameter vector - \n"
        buffer+="\tGENE_EXPRESSION_KINETIC_PARAMETER_VECTOR = Float64[]\n"
        if var gene_expression_rate_list = extractGeneExpressionRateList(model_root) {
            
            var counter = 1
            for proxy_object in gene_expression_rate_list {
            
                
                // write the record -
                //buffer+="\tpush!(IC_ARRAY,\(default_value!))\t"
                //buffer+="#\t\(counter)\t\(state_symbol!)\n"

                // update the counter -
                counter++
            }
        }
        
        
        buffer+="\n"
        buffer+="\t# - DO NOT EDIT BELOW THIS LINE ------------------------------ \n"
        buffer+="\tdata_dictionary = Dict()\n"
        buffer+="\tdata_dictionary[\"GENE_EXPRESSION_KINETIC_PARAMETER_VECTOR\"] = GENE_EXPRESSION_KINETIC_PARAMETER_VECTOR\n"
        buffer+="\tdata_dictionary[\"METABOLIC_KINETIC_PARAMETER_VECTOR\"] = METABOLIC_KINETIC_PARAMETER_VECTOR\n"
        buffer+="\tdata_dictionary[\"GENE_EXPRESSION_CONTROL_PARAMETER_VECTOR\"] = GENE_EXPRESSION_CONTROL_PARAMETER_VECTOR\n"
        buffer+="\tdata_dictionary[\"METABOLIC_CONTROL_PARAMETER_VECTOR\"] = METABOLIC_CONTROL_PARAMETER_VECTOR\n"
        buffer+="\tdata_dictionary[\"INITIAL_CONDITION_VECTOR\"] = IC_ARRAY\n"
        buffer+="\t# - DO NOT EDIT ABOVE THIS LINE ------------------------------ \n"
        buffer+="\treturn data_dictionary\n"
        buffer+="end\n"
        
        // return -
        return buffer
    }
    
    // MARK: - Helper methods
    func extractGeneExpressionRateList(root:SyntaxTreeComposite) -> [VLEMGeneExpressionRateProcessProxy]? {
     
        // get the list of rates involved in gene expression (includes degradation rates for both protein, and mRNA)
        var rate_visitor = GeneExpressionRateSyntaxTreeVistor()
        for child_node in root.children_array {
            child_node.accept(rate_visitor)
        }
        
        return rate_visitor.getSyntaxTreeVisitorData() as? [VLEMGeneExpressionRateProcessProxy]
    }
    
    func extractSpeciesList(root:SyntaxTreeComposite) -> [VLEMSpeciesProxy]? {
        
        // Get the list of species using the vistor pattern -
        var species_visitor = BiologicalSymbolSyntaxTreeVisitor()
        for child_node in root.children_array {
            child_node.accept(species_visitor)
        }
        
        return species_visitor.getSyntaxTreeVisitorData() as? [VLEMSpeciesProxy]
    }
}




